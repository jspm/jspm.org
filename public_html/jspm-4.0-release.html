<!DOCTYPE html><html lang="en"><head><link rel="alternate" title="JSPM" type="application/json" href="https://jspm.org/feed.json"><meta property="og:title" content="JSPM - JSPM 4.0 Release"><meta property="og:image" content="https://jspm.org/jspm.png"><meta name="Description" content="Discussing development and trust models for import map services"><meta property="og:description" content="Discussing development and trust models for import map services"><meta property="og:url" content="https://jspm.org/jspm-4.0-release"><meta name="twitter:card" content="summary_large_image">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <!-- Immediate dark mode styles to prevent flash -->
  <script>
    (function() {
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const isDark = savedTheme === 'dark' || (!savedTheme && prefersDark);
      
      // Update theme in localStorage if following system
      if (!savedTheme && prefersDark) {
        // We're using system preference - don't store anything in localStorage
      }
      
      if (isDark) {
        document.documentElement.style.colorScheme = 'dark';
        document.documentElement.classList.add('dark-mode');
        document.write('<style>:root{background-color:#1A202C!important;}body{background-color:#1A202C!important;color:#E2E8F0!important;} html.dark-mode body{background-color:#1A202C!important;color:#E2E8F0!important;} .topbar{background-color:#1A202C!important;border-color:#4A5568!important;} .sidebar{background-color:#2D3748!important;border-color:#4A5568!important;}</style>');
      }
    })();
  </script>
  <link rel="stylesheet" href="/style.css">
  <script defer="" src="/script.js"></script>
  <!-- Google tag (gtag.js) -->
  <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M0FZNQ9ZPV"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-M0FZNQ9ZPV');
  </script>
<title>JSPM - JSPM 4.0 Release</title></head>
<body class="page-jspm-4.0-release">
  <div class="topbar">
    <a href="/">
      <div class="logobox"></div>
      <h1 class="logo">JSPM</h1>
    </a>
    <ul class="toplinks">
      <li><a target="_blank" href="https://generator.jspm.io" rel="noopener">Online Generator</a></li>
      <li><a target="_blank" href="https://status.jspm.io" rel="noopener">CDN Status</a></li>
      <li><a target="_blank" href="https://opencollective.com/jspm" rel="noopener">Sponsor</a></li>
      <li class="theme-toggle" title="Toggle dark/light mode"></li>
      <li class="github"><a target="_blank" href="https://github.com/jspm/jspm" rel="noopener"></a></li>
    </ul>
    <div class="mobile-menu"></div>
  </div>

  <div class="sidebar">
    <div class="toc">
      <ul class="sections">
        <li>
          <a href="/getting-started">JSPM</a>
          <ul class="section">
            <li><a href="/getting-started">Getting Started</a></li>
            <li><a href="/faq">FAQ</a></li>
          </ul>
        </li>

        <li>
          <a href="/docs/cli">Documentation</a>
          <ul class="section">
            <li><a href="/docs/cli">JSPM CLI</a></li>
            <li><a href="/docs/generator">JSPM Generator</a></li>
            <li><a href="/docs/integrations">Integrations</a></li>
            <li><a href="/docs/cdn-resolution">CDN Resolution</a></li>
          </ul>
        </li>

        <li>
          <a href="/cdn/jspm-io">CDN</a>
          <ul class="section">
            <li><a href="/cdn/jspm-io">JSPM.IO</a></li>
            <li><a href="/cdn/api">API</a></li>
          </ul>
        </li>

        <li class="blog">
          <a href="/jspm-cli">Blog</a>
          <ul class="section">
            <li class="blog-link"><a href="/jspm-4.0-release"><em>JSPM 4.0 Release</em></a></li>
            <li class="blog-link"><a href="/js-integrity-with-import-maps"><em>JavaScript Integrity Manifests with Import Maps</em></a></li>
            <li class="blog-link"><a href="/jspm-dev-deprecation"><em>Deprecating jspm.dev</em></a></li>
          </ul>
        </li>
      </ul>
    </div>
  </div>


  <div class="content-container">
    <div class="content"><h1>JSPM 4.0 Release</h1>
<p>JSPM 4.0 is now out, featuring a new opinionated standards-based workflow that puts convention over configuration. It provides an alternative modern workflow for working with native ESM workflows in the browser using import maps:</p>
<ul>
<li><code>jspm install</code> without any arguments creates the <code>importmap.js</code> file.</li>
<li><code>jspm serve</code> behaves as a static server except for supporting TypeScript type stripping and hot reloading.</li>
<li><code>jspm build</code> uses the same semantics as the above commands to provide zero config standards-based builds.</li>
</ul>
<p>Read the updated <a href="/getting-started">Getting Started</a> guide for more info, or continue reading below for the background on how this release came together.</p>
<a name="standards-based-workflows" class="anchor main"></a><h2>Standards Based Workflows</h2>
<p>Leaning into standards means that developers can focus on writing JavaScript without learning custom build toolchains or frameworks. The JSPM 4.0 workflow takes advantage of the latest browser capabilities:</p>
<ol>
<li><strong>Native ES Modules</strong>: Use standard import/export syntax without transpilation</li>
<li><strong>Import Maps</strong>: Handle dependency mapping directly in the browser</li>
<li><strong>TypeScript Type Stripping</strong>: TypeScript type stripping as the only code transform</li>
<li><strong>No Custom Loaders</strong>: Everything runs on standard browser semantics</li>
</ol>
<p>This standards-first approach has several major benefits:</p>
<ul>
<li><strong>Simplified Debugging</strong>: Browser DevTools work naturally with standard modules, no source maps needed</li>
<li><strong>Portable Code</strong>: Fewer framework-specific conventions means easier migration</li>
<li><strong>Future-Proof</strong>: As standards evolve, your code remains compliant</li>
<li><strong>Reduced Tooling</strong>: Less configuration, fewer build steps, and smaller bundles</li>
<li><strong>Instant Development</strong>: JSPM import maps can even be generated in the browser for instant sandbox workflows, a technique used by Framer, one of the major project sponsors.</li>
</ul>
<a name="import-map-package-management" class="anchor main"></a><h2>Import Map Package Management</h2>
<p>One of the major changes in JSPM 4.0 is import maps are now treated as package management artifacts more like lock files than manifests for hand-editing.</p>
<p>All package management operations output by default to the new <code>importmap.js</code> import map injection script file. This is effectively a workaround for the lack of external import map support for an <code>importmap.json</code> file in browsers. The injection script has been recently widely support thanks to the new support for multiple import maps:</p>
<pre><code class="language-html">&lt;script type=<span class="string">"importmap"</span> src=<span class="string">"https://site.com/importmap.json"</span>&gt;&lt;/script&gt;
&lt;script type=<span class="string">"module"</span>&gt;<span class="keyword">import</span> <span class="string">'app'</span>&lt;/script&gt;
</code></pre>
<p>The injection script itself then directly inlines the new import map into the browser:</p>
<pre><code class="language-js">(map =&gt; {
  document.head.appendChild(Object.assign(document.createElement(<span class="string">"script"</span>), {
    type: <span class="string">"importmap"</span>,
    innerHTML: JSON.stringify(map)
  }));
})
({
  <span class="string">"imports"</span>: {
    <span class="string">"my-app"</span>: <span class="string">"./src/index.js"</span>
<span class="comment">    // ... imports</span>
  },
  <span class="string">"scopes"</span>: {
<span class="comment">    // ... scopes</span>
  }
});
</code></pre>
<p>With the above, using just native browser semantics it is possible to run any browser application instantly.</p>
<a name="packagejson-is-the-manifest" class="anchor main"></a><h2>Package.json is the Manifest</h2>
<p>Instead of hand-editing the <code>importmap.js</code> file, JSPM now figures out what dependencies are needed and at what versions and updates the map.</p>
<p>The information for how to link the application, and what dependency constraints is then taken from the local <code>package.json</code> file.</p>
<p>The key idea here is that we can define the application entry points from the package.json using the <code><span class="string">"name"</span></code> and <code><span class="string">"exports"</span></code> package.json fields.</p>
<p>For example, for a package.json containing:</p>
<pre><code class="language-json">{
  <span class="string">"name"</span>: <span class="string">"my-app"</span>,
  <span class="string">"exports"</span>: {
    <span class="string">"."</span>: <span class="string">"./src/index.js"</span>
  },
  <span class="string">"dependencies"</span>: {
    <span class="string">"foo"</span>: <span class="string">"<span class="number">1</span>.<span class="number">2</span>.<span class="number">3</span>"</span>
  }
}
</code></pre>
<p>JSPM will know when the user runs <code>jspm install</code> that there should be a <code><span class="string">"my-app"</span></code> import in the import map pointing to <code><span class="string">"./src/index.js"</span></code>.</p>
<p>It will then link (<em>trace</em>) that entry point and its dependencies in turn, populating dependencies into scopes while respecting the package.json <code><span class="string">"dependencies"</span></code> resolution ranges.</p>
<p>As a result, the only imports at the top-level <code><span class="string">"imports"</span></code> of the import map will be the enumerated <code><span class="string">"exports"</span></code> entry points (which also support subpath patterns).</p>
<p><strong>It was surprisingly hard to figure out good import map ergonomics for the project but this is a huge simplication that forms the new convention for the project going forward.</strong></p>
<p>Of course we still support <code>--out</code>, <code>--map</code> and <code>--resolution</code> flags (amongs <a href="/docs/cli/interfaces/GenerateFlags">others</a>) for custom map inputs and outputs including JSON and HTML outputs as previously. <code>jspm link</code> is also still supported for the more complex map manipulation workflows. But the important point here is that if we get past treating maps as a user-based manifest and let JSPM act as the linker that figures it out based on constraints, we get some really great ergonomics out of import maps development.</p>
<a name="hot-reloading-server" class="anchor main"></a><h2>Hot Reloading Server</h2>
<p>The JSPM 4.0 server (<code>jspm serve</code>) provides a development environment with instant hot module reloading built off the same conventions as install:</p>
<ul>
<li><strong>Zero Configuration</strong>: Start serving your application with a single command.</li>
<li><strong>Fast Refresh</strong>: Changes to your code are reflected instantly in the browser.</li>
<li><strong>TypeScript Support</strong>: Write TypeScript without a separate build step.</li>
<li><strong>Import Map Awareness</strong>: Handles import map updates without refreshes.</li>
</ul>
<p>The hot reloading system works by injecting a Server Side Events connection into the import map injection script itself. When files change, the server notifies the client and ES Module Shims handles the reloading of only the affected modules, preserving application state supporting the <code><span class="keyword">import</span>.meta.hot</code> API.</p>
<blockquote>
<p>The hot reloading server is made possible by <a href="https://github.com/guybedford/es-module-shims" target="_blank" rel="noopener">ES Module Shims</a>, which is used in JSPM to polyfill import map features in older browsers like multiple import maps support, recently adding support for hot reloading.</p>
</blockquote>
<a name="building-for-production" class="anchor main"></a><h2>Building for Production</h2>
<p>The semantics of <code>jspm build</code> follow from the same standards-based runtime semantics.</p>
<p><em>Then, instead of building the <code>dist</code> folder inside the package, we build the whole package, and output the new optimized package into the <code>dist</code> folder.</em></p>
<p>This is very much the same thing as what the JSPM.IO CDN already does today for npm packages, but available locally.</p>
<p>What makes this possible is clearly defining the application entry points, which we enforce from the start with <code>jspm install</code>, so that the package optimization is fully well defined without having to set the build entry points.</p>
<a name="cdn-trust-models-and-future-direction" class="anchor main"></a><h2>CDN Trust Models and Future Direction</h2>
<p>The core ergonomics of JSPM 4.0 still rely heavily on CDNs providing optimized packages for seamless import map generation. In-browser workflows are supported just as well as local CLI workflows, and the AI sandbox use cases with module CDNs are important to support.</p>
<p>To give some background - the first versions of JSPM focused primarily on local packagae semantics but ultimately fell short on standards-based workflows, when custom loaders were required that created friction in the developer experience.</p>
<p>Solving the CDN provider ecosystem ergonomics first Since JSPM 4.0, we've dramatically shifted our approach to solving the CDN provider ecosystem first. The JSPM generator now supports multiple CDN providers (jspm.io, unpkg, jsdelivr, skypack, and others), giving developers the freedom to choose their provider or even mix providers within a single import map. This provider-agnostic approach directly addresses the lock-in problem that has historically been a concern with CDN-based workflows.</p>
<p><code>jspm.io</code> itself, as a module CDN provider, has been adopted by frameworks such as Rails and is used internally in Framer Sites for instant in-browser code loading. However, we recognize that trust and security remain critical considerations. Our roadmap for the future centers around three key principles to build a trustless module ecosystem:</p>
<ol>
<li><strong>Permanent URLs</strong>: Ensuring content-addressable, immutable package URLs that can be reliably cached and verified</li>
<li><strong>Integrity Support</strong>: Working with browser vendors on full import map integrity support (see <a href="/js-integrity-with-import-maps">JavaScript Integrity Manifests with Import Maps</a>)</li>
<li><strong>Provider Interchangeability</strong>: Continuing to improve standards and conventions that make switching CDN providers seamless. Clear conventions and standards here is the key to avoiding lock-in.</li>
</ol>
<p>The JSPM Foundation aims to contribute to this trustless infrastructure for module delivery based on the sponsorships we receive, while developing the open source tooling that treats module CDNs as interchangeable providers. While we've made significant progress with JSPM 4.0, tackling the trust problem comprehensively remains a major future goal for the project.</p>
<p>As we continue to build out these standards and tools for native modules, our hope is that the broader ecosystem will embrace clear conventions around verifiability and integrity as essential foundations for the future of code execution on the web.</p>
<div class="nextprev"><div class="edit-container"><a class="edit" target="_blank" href="https://github.com/jspm/jspm.org/blob/main/pages/jspm-4.0-release.md" rel="noopener">Edit</a></div></div></div>
  </div>

</body></html>