<!DOCTYPE html><html lang="en"><head><link rel="alternate" title="jspm.org" type="application/json" href="https://jspm.org/feed.json"><meta property="og:title" content="jspm.org - Workflow Guides - Documentation"><meta property="og:image" content="https://jspm.org/jspm.png"><meta name="Description" content="JSPM workflows overview and introduction"><meta property="og:description" content="JSPM workflows overview and introduction"><meta property="og:url" content="https://jspm.org/docs/workflows"><meta name="twitter:card" content="summary_large_image"><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style.css?v1">
<link rel="preload" as="font" href="/sourcesans-light.woff2" type="font/woff2" crossorigin="anonymous">
<script defer="" src="/script.js?v1"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-40327700-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-40327700-2');
</script>
<title>Workflow Guides - Documentation - jspm.org</title></head><body class="page-docs-workflows">
<div class="topbar">
  <a style="display: block" href="/">
    <div class="logobox" href="/"></div>
    <h1 class="logo">jspm</h1>
  </a>
  <ul class="toplinks"><!--<li><a target="_blank" href="/import-map-cdn">Latest Release</a></li>--><li><a target="_blank" href="/docs/cdn" rel="noopener">Docs</a></li><li><a target="_blank" href="https://generator.jspm.io" rel="noopener">Online Generator</a></li><li><a target="_blank" href="https://status.jspm.io" rel="noopener">CDN Status</a></li><li class="github"><a target="_blank" href="https://github.com/jspm/project" rel="noopener"></a></li></ul>
  <div class="mobile-menu"></div>
</div>
<div class="sidebar">
  <div class="toc">
    <ul class="sections">
      <li class="docs">
        <a>Docs</a>
        <ul class="section">
          <li class="guide"><a href="/docs/workflows">Workflow Guides</a></li>
          <li class="guide"><a href="/docs/cdn">CDN Architecture</a></li>
          <li class="guide"><a href="/docs/api">CDN API</a></li>
          <li class="guide"><a href="/docs/cli">CLI</a></li>
        </ul>
      </li>
      <li class="about">
        <a>Posts</a>
        <ul class="section">
          <li class="blog-link"><a href="/teleporthq-sponsorship"><em>TeleportHQ Sponsorship<span class="date">15/03/22</span></em></a></li>
          <li class="blog-link"><a href="/import-map-cdn"><em>Import Map CDN Launch<span class="date">02/03/21</span></em></a></li>
          <li class="blog-link"><a href="/jspm-dev-release"><em>JSPM.dev Release<span class="date">19/06/20</span></em></a></li>
        </ul>
      </li>
      <li><a>Resources</a>
        <ul>
          <li><a href="https://generator.jspm.io" target="_blank" rel="noopener">Online Import Map Generator</a></li>
          <li><a href="/sandbox">Online Sandbox</a></li>
          <li><a target="_blank" href="https://github.com/jspm/project" rel="noopener">Issue Tracker</a></li>
          <li><a target="_blank" href="https://discord.gg/dNRweUu" rel="noopener">Discord</a></li>
          <li><a target="_blank" href="https://opencollective.com/jspm" rel="noopener">Open Collective</a></li>
          <li><a target="_blank" href="https://twitter.com/jspm" rel="noopener">@jspm on Twitter</a></li>
        </ul>
        </li>
    </ul>
    <div class="footer"><p>
      Logo design by <a target="_blank" href="https://www.luuk.site/" rel="noopener">Luuk de Vlieger</a>
    </p></div>
  </div>
</div>
<div class="content-container">
  <div class="content"><h1>Workflow Guides</h1>
<p>Some simple workflows for getting started with JSPM import map generation.</p>
<ul>
<li>For quick examples without getting bogged down in local tooling configuration, try the <a href="#online-generator">Online Generator</a> or <a href="#vscode-extension">VSCode Extension</a> workflows below.</li>
<li>The most direct recommended approach for JSPM Generation is the <a href="#js-generator-api">JS Generator API</a> workflow.</li>
<li>For a full example local application with TypeScript and a dev server using the Chomp task runner (or alternatively npm scripts), see the <a href="#jspm-starter">JSPM Starter</a> workflow.</li>
<li>More advanced experimental <a href="#deno-import-maps">Deno import maps</a> support is demonstrated as the last workflow.</li>
</ul>
<a name="online-generator" class="anchor main"></a><h2>Online Generator</h2>
<p>The easiest way to try out JSPM is to generate an import map using the online generator at <a href="https://generator.jspm.io" target="_blank" rel="noopener">https://generator.jspm.io</a>.</p>
<div style="text-align: center;">
<a href="https://generator.jspm.io" target="_blank" rel="noopener"><img style="width: 100%" src="/steps/online-0.png"></a>
</div>

<p>In the top-left corner enter an npm package name to add to the import map (<code>lit</code> in this example):</p>
<div style="text-align: center;">
<img src="/steps/online-1.png">
</div>

<p>Press <code>Return</code> to add the package to the map. Then add any other dependency entries. For example to add the <code>./html.js</code> subpath export of lit, add <code>lit/html.js</code>:</p>
<div style="text-align: center;">
<img src="/steps/online-2.png">
</div>

<p>Versions are supported in package names before the subpath and items can be removed or changed from the controls provided.</p>
<p>The final import map is shown on the right, and can be retrieved as an HTML page template or as direct JSON.</p>
<p>In <a href="https://generator.jspm.io/#U2NhYGBiDs0rySzJSU1hyMkscTDSM9IzQLD0M0pyc/SyigHzBUtSKgA" target="_blank" rel="noopener">this example</a> we get:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=<span class="string">"utf-8"</span>&gt;
  &lt;title&gt;Untitled&lt;/title&gt;
  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=<span class="number">1</span>"</span>&gt;
&lt;/head&gt;
&lt;body&gt;
  <span class="comment">&lt;!--
    JSPM Generator Import Map
    Edit URL: https://generator.jspm.io/#U<span class="number">2</span>NhYGBiDs0rySzJSU<span class="number">1</span>hyMkscTDSM<span class="number">9</span>IzQLD<span class="number">0</span>M<span class="number">0</span>pyc/SyigHzBUtSKgA
  --&gt;</span>
  &lt;script type=<span class="string">"importmap"</span>&gt;
  {
    <span class="string">"imports"</span>: {
      <span class="string">"lit"</span>: <span class="string">"https://ga.jspm.io/npm:lit@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/index.js"</span>,
      <span class="string">"lit/html.js"</span>: <span class="string">"https://ga.jspm.io/npm:lit@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/html.js"</span>
    },
    <span class="string">"scopes"</span>: {
      <span class="string">"https://ga.jspm.io/"</span>: {
        <span class="string">"@lit/reactive-element"</span>: <span class="string">"https://ga.jspm.io/npm:@lit/reactive-element@<span class="number">1</span>.<span class="number">3</span>.<span class="number">0</span>/reactive-element.js"</span>,
        <span class="string">"lit-element/lit-element.js"</span>: <span class="string">"https://ga.jspm.io/npm:lit-element@<span class="number">3</span>.<span class="number">2</span>.<span class="number">0</span>/lit-element.js"</span>,
        <span class="string">"lit-html"</span>: <span class="string">"https://ga.jspm.io/npm:lit-html@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/lit-html.js"</span>
      }
    }
  }
  &lt;/script&gt;
  
  <span class="comment">&lt;!-- ES Module Shims: Import maps polyfill <span class="keyword">for</span> modules browsers without <span class="keyword">import</span> maps support (all except Chrome <span class="number">89</span>+) --&gt;</span>
  &lt;script <span class="keyword">async</span> src=<span class="string">"https://ga.jspm.io/npm:es-module-shims@<span class="number">0</span>.<span class="number">12</span>.<span class="number">8</span>/dist/es-module-shims.min.js"</span> crossorigin=<span class="string">"anonymous"</span>&gt;&lt;/script&gt;
  
  &lt;script type=<span class="string">"module"</span>&gt;
    <span class="keyword">import</span> * <span class="keyword">as</span> lit <span class="keyword">from</span> <span class="string">"lit"</span>;
    <span class="keyword">import</span> * <span class="keyword">as</span> litHtml <span class="keyword">from</span> <span class="string">"lit/html.js"</span>;
<span class="comment">  
    // Write main module code here, or <span class="keyword">as</span> a separate file with a <span class="string">"src"</span> attribute on the module script.</span>
    console.log(lit, litHtml);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Saving the HTML template locally and serving over a local server provides a full native modules workflow for working with remote npm packages without needing any separate build steps.</p>
<p>The included <a href="https://github.com/guybedford/es-module-shims" target="_blank" rel="noopener">ES Module Shims polyfill</a> ensures the workflow works in all browsers with native modules support.</p>
<a name="vscode-extension" class="anchor main"></a><h2>VSCode Extension</h2>
<p>For an easy fully local workflow try the <a href="https://marketplace.visualstudio.com/items?itemName=JSPM.jspm-vscode" target="_blank" rel="noopener">JSPM Generator VSCode Extension</a>, which is supported as a Web Extension.</p>
<p>This provides a workflow for writing native HTML imports directly, then post-processing the HTML file to insert the generated import map and polyfill.</p>
<p>With the extension installed, create a new VSCode project, with an <code>app.html</code> file:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;head&gt;
&lt;script type=<span class="string">"module"</span> src=<span class="string">"./lib/app.js"</span>&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
</code></pre>
<p>Then create a new JS file <code>lib/app.js</code>:</p>
<pre><code class="language-js"><span class="keyword">import</span> lit <span class="keyword">from</span> <span class="string">'lit'</span>;
console.log(lit);
</code></pre>
<p>With the editor focus on <code>app.html</code> open the VSCode Command Palette (<code>Ctrl + Shift + P</code>) and select the <code>JSPM: Generate Import Map</code> command</p>
<div style="text-align: center;">
<img src="/steps/vscode-1.png">
</div>

<p>The first question will be whether to inject preloads and integrity for the generation process, in this case select <code>No</code>:</p>
<div style="text-align: center;">
<img src="/steps/vscode-2.png">
</div>

<p>This preference can also be saved and changed any time from the VSCode JSPM Settings.</p>
<p>The final question is what environments to generate the import map for. The default generation is with the <code>browser</code>, <code>development</code> and <code>module</code> exports conditions, in this case we select a <code>production</code> instead of a <code>development</code> import map:</p>
<div style="text-align: center;">
<img src="/steps/vscode-3.png">
</div>

<p>Press return again and the generator will run the complete generation API from within VSCode, modifying the HTML to include the injected import map on completion.</p>
<p>The <code>app.html</code> file will then be updated by the extension with the ES Module Shims polyfill and import map tags:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;head&gt;
<span class="comment">&lt;!-- Generated by @jspm/generator VSCode Extension - https://github.com/jspm/jspm-vscode --&gt;</span>
&lt;script <span class="keyword">async</span> src=<span class="string">"https://ga.jspm.io/npm:es-module-shims@<span class="number">1</span>.<span class="number">4</span>.<span class="number">7</span>/dist/es-module-shims.js"</span> crossorigin=<span class="string">"anonymous"</span>&gt;&lt;/script&gt;
&lt;script type=<span class="string">"importmap"</span>&gt;
{
  <span class="string">"scopes"</span>: {
    <span class="string">"./"</span>: {
      <span class="string">"lit"</span>: <span class="string">"https://ga.jspm.io/npm:lit@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/index.js"</span>
    },
    <span class="string">"https://ga.jspm.io/"</span>: {
      <span class="string">"@lit/reactive-element"</span>: <span class="string">"https://ga.jspm.io/npm:@lit/reactive-element@<span class="number">1</span>.<span class="number">3</span>.<span class="number">0</span>/reactive-element.js"</span>,
      <span class="string">"lit-element/lit-element.js"</span>: <span class="string">"https://ga.jspm.io/npm:lit-element@<span class="number">3</span>.<span class="number">2</span>.<span class="number">0</span>/lit-element.js"</span>,
      <span class="string">"lit-html"</span>: <span class="string">"https://ga.jspm.io/npm:lit-html@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/lit-html.js"</span>
    }
  }
}
&lt;/script&gt;
&lt;script type=<span class="string">"module"</span> src=<span class="string">"./lib/app.js"</span>&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
</code></pre>
<p>Rewriting will carefully respect existing HTML and existing import mappings. The operation is also largely idempotent unless there are resolution differences.</p>
<p>Version ranges will be consulted from any local <code>package.json</code> file. The full Node.js resolver rules are supported so it's even possible to use <a href="https://nodejs.org/dist/latest-v17.x/docs/api/packages.html#self-referencing-a-package-using-its-name" target="_blank" rel="noopener">own-name resolution</a> and <a href="https://nodejs.org/dist/latest-v17.x/docs/api/packages.html#subpath-imports" target="_blank" rel="noopener">package imports resolution</a> while respecting custom local import map mappings.</p>
<p>After processing, <code>app.html</code> should then be a fully executable HTML application. For production it is usually advisable to use the preload option which will inject integrity as well for static guarantees.</p>
<a name="js-generator-api" class="anchor main"></a><h2>JS Generator API</h2>
<p>The <a href="https://github.com/jspm/generator" target="_blank" rel="noopener"><code>@jspm/generator</code> project</a> is the driver of all the workflows here. It provides a CDN agnostic protocol for generating import maps for any local or remote URLs, and even supports custom CDN providers and alternative protocols like IPFS.</p>
<p>To run the generator locally, it can be installed from <code>@jspm/generator</code> on npm:</p>
<pre><code class="language-sh">npm install @jspm/generator
</code></pre>
<p>The documentation and typings are available from the <a href="https://github.com/jspm/generator" target="_blank" rel="noopener">project repo</a>.</p>
<p>Below are two basic usage examples for generating import maps like the online generator and VSCode extension respectively.</p>
<a name="import-map-generation" class="anchor"></a><h3>Import Map Generation</h3>
<p>In a new project, install the <code>@jspm/generator</code>:</p>
<pre><code class="language-sh">npm install @jspm/generator --save-dev
</code></pre>
<p>Then edit the <code>package.json</code> file to include <code><span class="string">"type"</span>: <span class="string">"module"</span></code> or use an <code>.mjs</code> file then write the build script:</p>
<p>jspm-generate.js</p>
<pre><code class="language-js"><span class="keyword">import</span> { Generator } <span class="keyword">from</span> <span class="string">'@jspm/generator'</span>;

<span class="keyword">const</span> generator = <span class="keyword">new</span> Generator({
  mapUrl: <span class="keyword">import</span>.meta.url,
  env: [<span class="string">'browser'</span>, <span class="string">'development'</span>, <span class="string">'module'</span>]
});

<span class="keyword">await</span> generator.install(<span class="string">'lit'</span>);
<span class="keyword">await</span> generator.install(<span class="string">'lit/html.js'</span>);

console.log(JSON.stringify(generator.getMap(), null, <span class="number">2</span>));
</code></pre>
<p>Running the above, will output the equivalent map that the online sandbox would have provided:</p>
<pre><code class="language-sh">node jspm-generate.js
</code></pre>
<p>with output:</p>
<pre><code class="language-json">{
  <span class="string">"imports"</span>: {
    <span class="string">"lit"</span>: <span class="string">"https://ga.jspm.io/npm:lit@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/index.js"</span>,
    <span class="string">"lit/html.js"</span>: <span class="string">"https://ga.jspm.io/npm:lit@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/html.js"</span>
  },
  <span class="string">"scopes"</span>: {
    <span class="string">"https://ga.jspm.io/"</span>: {
      <span class="string">"@lit/reactive-element"</span>: <span class="string">"https://ga.jspm.io/npm:@lit/reactive-element@<span class="number">1</span>.<span class="number">3</span>.<span class="number">0</span>/development/reactive-element.js"</span>,
      <span class="string">"lit-element/lit-element.js"</span>: <span class="string">"https://ga.jspm.io/npm:lit-element@<span class="number">3</span>.<span class="number">2</span>.<span class="number">0</span>/development/lit-element.js"</span>,
      <span class="string">"lit-html"</span>: <span class="string">"https://ga.jspm.io/npm:lit-html@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/development/lit-html.js"</span>
    }
  }
}
</code></pre>
<a name="html-generation" class="anchor"></a><h3>HTML Generation</h3>
<p>For a full HTML generation workflow, follow the same steps of the previous example, but use the <code>generate.htmlGenerate</code> method instead in the <code>jspm-generate.js</code> file:</p>
<p>jspm-generate.js</p>
<pre><code class="language-js"><span class="keyword">import</span> { Generator } <span class="keyword">from</span> <span class="string">'@jspm/generator'</span>;

<span class="keyword">const</span> generator = <span class="keyword">new</span> Generator({
  mapUrl: <span class="keyword">import</span>.meta.url,
  env: [<span class="string">'browser'</span>, <span class="string">'development'</span>, <span class="string">'module'</span>]
});

console.log(<span class="keyword">await</span> generator.htmlGenerate(<span class="string">`
&lt;!doctype html&gt;
&lt;head&gt;
&lt;script type=<span class="string">"module"</span>&gt;
<span class="keyword">import</span> lit <span class="keyword">from</span> <span class="string">'lit'</span>;
console.log(lit);
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
`</span>, {
  htmlUrl: <span class="keyword">import</span>.meta.url,
  preload: <span class="keyword">false</span>
}));
</code></pre>
<pre><code class="language-sh">node jspm-generate.js
</code></pre>
<p>with output:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;head&gt;
<span class="comment">&lt;!-- Generated by @jspm/generator - https://github.com/jspm/generator --&gt;</span>
&lt;script <span class="keyword">async</span> src=<span class="string">"https://ga.jspm.io/npm:es-module-shims@<span class="number">1</span>.<span class="number">4</span>.<span class="number">7</span>/dist/es-module-shims.js"</span> crossorigin=<span class="string">"anonymous"</span>&gt;&lt;/script&gt;
&lt;script type=<span class="string">"importmap"</span>&gt;
{
  <span class="string">"imports"</span>: {
    <span class="string">"lit"</span>: <span class="string">"https://ga.jspm.io/npm:lit@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/index.js"</span>
  },
  <span class="string">"scopes"</span>: {
    <span class="string">"https://ga.jspm.io/"</span>: {
      <span class="string">"@lit/reactive-element"</span>: <span class="string">"https://ga.jspm.io/npm:@lit/reactive-element@<span class="number">1</span>.<span class="number">3</span>.<span class="number">0</span>/development/reactive-element.js"</span>,
      <span class="string">"lit-element/lit-element.js"</span>: <span class="string">"https://ga.jspm.io/npm:lit-element@<span class="number">3</span>.<span class="number">2</span>.<span class="number">0</span>/development/lit-element.js"</span>,
      <span class="string">"lit-html"</span>: <span class="string">"https://ga.jspm.io/npm:lit-html@<span class="number">2</span>.<span class="number">2</span>.<span class="number">0</span>/development/lit-html.js"</span>
    }
  }
}
&lt;/script&gt;
&lt;script type=<span class="string">"module"</span>&gt;
<span class="keyword">import</span> lit <span class="keyword">from</span> <span class="string">'lit'</span>;
console.log(lit);
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
</code></pre>
<p>Exactly as per the VSCode Extension above, external module imports via <code>&lt;script type=<span class="string">"module"</span> src=<span class="string">"./lib/app.js"</span>&gt;&lt;/script&gt;</code> will also be traced and generated and version ranges will be consulted from any local <code>package.json</code> file.</p>
<p>The full Node.js resolver rules are supported so it's even possible to use <a href="https://nodejs.org/dist/latest-v17.x/docs/api/packages.html#self-referencing-a-package-using-its-name" target="_blank" rel="noopener">own-name resolution</a> and <a href="https://nodejs.org/dist/latest-v17.x/docs/api/packages.html#subpath-imports" target="_blank" rel="noopener">package imports resolution</a> while respecting custom local import map mappings.</p>
<a name="jspm-starter" class="anchor main"></a><h2>JSPM Starter</h2>
<p>While the previous workflows all show isolated examples of import map generation, the <a href="https://github.com/jspm/jspm-starter" target="_blank" rel="noopener">JSPM Starter repo</a> provides a full featured development example with TypeScript support.</p>
<p>It is recommended to use <a href="https://chompbuild.com" target="_blank" rel="noopener">Chomp Task Runner</a> instead of npm scripts for the starter, which provides Makefile-like incremental builds with caching as well as a dev server.</p>
<a name="chomp-setup" class="anchor"></a><h3>Chomp Setup</h3>
<p>Chomp can be installed either via npm:</p>
<pre><code class="language-sh">npm install -g chomp
</code></pre>
<p>or with the <a href="https://rustup.rs/" target="_blank" rel="noopener">Rust Toolchain</a>:</p>
<pre><code class="language-sh">cargo install chompbuild
</code></pre>
<p>Once installed, verify the Chomp installation with:</p>
<pre><code class="language-sh">chomp --version
</code></pre>
<a name="setup" class="anchor"></a><h3>Setup</h3>
<p>Clone the <a href="https://github.com/jspm/jspm-starter" target="_blank" rel="noopener">jspm-starter</a> repo:</p>
<pre><code class="language-sh">git clone https://github.com/jspm/jspm-starter
cd jspm-starter
</code></pre>
<p>Next, run <code>npm install</code>.</p>
<a name="npm-scripts-workflow" class="anchor"></a><h3>npm Scripts Workflow</h3>
<p>For the traditional npm scripts workflow, run:</p>
<pre><code class="language-sh">npm run build
</code></pre>
<p>Then use your preferred local server to navigate to the <code>app.html</code> file to see the working application.</p>
<p>TypeScript is compiled with <code>tsc</code> and a local generation API command is run per the <a href="#js-generator-api">JS API workflow</a> above.</p>
<a name="chomp-workflow" class="anchor"></a><h3>Chomp Workflow</h3>
<p>For the Chomp workflow run:</p>
<pre><code class="language-sh">chomp build --serve
</code></pre>
<p>which will spin up a dev server on <code>http://localhost:5776/</code>.</p>
<p>The necessary build steps as needed by the task graph will be performed by Chomp as well as serving the project folder.</p>
<p>Open up a browser window (or even the simple browser window in VSCode from the command pallet) and navigate to <code>http://localhost:5776/app.html</code>.</p>
<p>You should see a working clickable animated slider. Any changed made will incrementally rebuild - try editing the original TypeScript file in <code>src/motion-slide.ts</code>.</p>
<p>Chomp works to a task graph defined in a <code>chompfile.toml</code> with Makefile-style invalidation to only incrementally recompile individual files as necessary. Because the JSPM task depends on the <code>lib</code> files transitively (which are compiled by TypeScript from <code>src</code>), the generator will also automatically rerun as files change to pick up any new resolutions for the import map.</p>
<p>Refreshing the page gives an instant dev workflow (and <a href="https://github.com/guybedford/es-module-shims/pull/269" target="_blank" rel="noopener">hot reloading</a> is on the roadmap).</p>
<p>Here's the <code>chompfile.toml</code> for the complete build process:</p>
<p>chompfile.toml</p>
<pre><code class="language-toml">version = <span class="number">0</span>.<span class="number">1</span>
default-task = <span class="string">'build'</span>

extensions = [<span class="string">'chomp@<span class="number">0</span>.<span class="number">1</span>:swc'</span>]

[[task]]
name = <span class="string">'build'</span>
deps = [<span class="string">'app.html'</span>]

[[task]]
target = <span class="string">'lib/#.js'</span>
dep = <span class="string">'src/#.ts'</span>
template = <span class="string">'swc'</span>
[task.template-options]
<span class="string">'jsc.target'</span> = <span class="string">'es2019'</span>
source-maps = <span class="keyword">false</span>

[[task]]
target = <span class="string">'app.html'</span>
deps = [<span class="string">'app.html'</span>, <span class="string">'lib/**/*.js'</span>]
engine = <span class="string">'node'</span>
run = <span class="string"><span class="string">''</span><span class="string">'
<span class="keyword">import</span> { Generator } <span class="keyword">from</span> '</span>@jspm/generator<span class="string">';
<span class="keyword">import</span> { readFile, writeFile } <span class="keyword">from</span> '</span>fs/promises<span class="string">';
<span class="keyword">import</span> { pathToFileURL } <span class="keyword">from</span> '</span>url<span class="string">';

<span class="keyword">const</span> generator = <span class="keyword">new</span> Generator({
  mapUrl: pathToFileURL('</span>app.html<span class="string">'),
  env: ['</span>production<span class="string">', '</span>browser<span class="string">', '</span>module<span class="string">']
});

<span class="keyword">const</span> htmlSource = <span class="keyword">await</span> readFile('</span>app.html<span class="string">', '</span>utf-8<span class="string">');

<span class="keyword">await</span> writeFile('</span>app.html<span class="string">', <span class="keyword">await</span> generator.htmlGenerate(htmlSource, {
  preload: <span class="keyword">true</span>,
  integrity: <span class="keyword">true</span>
}));
'</span><span class="string">''</span></span>
</code></pre>
<p>SWC is used to compile TypeScript using an SWC template provided by the <code>chomp@<span class="number">0</span>.<span class="number">1</span>:swc</code> <a href="https://github.com/guybedford/chomp-extensions" target="_blank" rel="noopener">Chomp extension</a>. The <code>#</code> symbol means the task is interpolated with a glob over all files - SWC is run individually on each file just like a Makefile would do.</p>
<p>Each task optionally defines its targets and dependencies which informs the caching rules and forms a graph of tasks to run with maximum parallelism. Tasks have a <code>run</code> field which can be shell or JavaScript code that should run to execute the task.</p>
<p>The JSPM task is expanded for understandability, but there is actually a JSPM Chomp extension we could use instead to give the Chompfile:</p>
<pre><code class="language-toml">version = <span class="number">0</span>.<span class="number">1</span>
default-task = <span class="string">'build'</span>

extensions = [<span class="string">'chomp@<span class="number">0</span>.<span class="number">1</span>:jspm'</span>, <span class="string">'chomp@<span class="number">0</span>.<span class="number">1</span>:swc'</span>]

[[task]]
name = <span class="string">'build'</span>
deps = [<span class="string">'app.html'</span>]

[[task]]
target = <span class="string">'lib/#.js'</span>
dep = <span class="string">'src/#.ts'</span>
template = <span class="string">'swc'</span>
[task.template-options]
<span class="string">'jsc.target'</span> = <span class="string">'es2019'</span>
source-maps = <span class="keyword">false</span>

[[task]]
target = <span class="string">'app.html'</span>
deps = [<span class="string">'app.html'</span>, <span class="string">'lib/**/*.js'</span>]
template = <span class="string">'jspm'</span>
[task.template-options]
env = [<span class="string">'production'</span>, <span class="string">'browser'</span>, <span class="string">'module'</span>]
preload = <span class="keyword">true</span>
integrity = <span class="keyword">true</span>
</code></pre>
<p>While somewhat magical, template extensions can always be ejected to see their real task definitions. Try updating the Chompfile to the above then running <code>chomp --eject</code> to see this in action.</p>
<a name="chomp-resources" class="anchor"></a><h3>Chomp Resources</h3>
<p>For more information about Chomp, resources are provided below:</p>
<ul>
<li><a href="https://github.com/guybedford/chomp#getting-started" target="_blank" rel="noopener">Getting Started</a></li>
<li><a href="https://github.com/guybedford/chomp/blob/main/docs/cli.md" target="_blank" rel="noopener">Chomp CLI</a></li>
<li><a href="https://github.com/guybedford/chomp/blob/main/docs/chompfile.md" target="_blank" rel="noopener">Chompfile Definition</a></li>
<li><a href="https://github.com/guybedford/chomp/blob/main/docs/task.md" target="_blank" rel="noopener">Task Definitions</a></li>
<li><a href="https://github.com/guybedford/chomp/blob/main/docs/extensions.md" target="_blank" rel="noopener">Chomp Extensions</a></li>
</ul>
<a name="deno-import-maps" class="anchor main"></a><h2>Deno Import Maps</h2>
<p>Since CommonJS -&gt; ESM conversion and conditional environment resolution is an integral part of the JSPM import map generation, constructing import maps to support execution of npm packages in Deno or other non-browser environments is possible using the same techniques.</p>
<p>This provides a novel mechanism for executing npm packages in Deno, thanks to the ability to support <a href="https://jspm/jspm-core" target="_blank" rel="noopener">JSPM Core</a> to link against the <a href="https://github.com/denoland/deno_std/tree/main/node" target="_blank" rel="noopener">Deno shims of the Node.js standard libraries</a>.</p>
<p>For example, let's run <code>@jspm/generator</code> itself in Deno.</p>
<p>This example again uses <a href="https://chompbuild.com" target="_blank" rel="noopener">Chomp</a> but the any generation API from these workflows can be used equivalently as long as the environment is set to <code>env: [<span class="string">'deno'</span>, <span class="string">'module'</span>, <span class="string">'browser'</span>, <span class="string">'production'</span>]</code> (or development).</p>
<p>With <a href="#chomp-setup">Chomp installed</a>, create a new <code>chompfile.toml</code>:</p>
<p>chompfile.toml</p>
<pre><code class="language-toml">version = <span class="number">0</span>.<span class="number">1</span>

extensions = [<span class="string">'chomp@<span class="number">0</span>.<span class="number">1</span>:jspm'</span>]

# Chomp itself uses a local npm version of @jspm/generator
# This will automatically install that <span class="keyword">for</span> us <span class="keyword">as</span> necessary
# (saving running a manual npm install)
[template-options.npm]
auto-install = <span class="keyword">true</span>

[[task]]
target = <span class="string">'importmap.json'</span>
deps = [<span class="string">'deno-generate.ts'</span>]
template = <span class="string">'jspm'</span>
[task.template-options]
env = [<span class="string">'deno'</span>, <span class="string">'browser'</span>, <span class="string">'module'</span>, <span class="string">'production'</span>]
</code></pre>
<p>For the example generation, create <code>deno-generate.ts</code> that runs a simple Lit generation:</p>
<p>deno-generate.ts</p>
<pre><code class="language-ts"><span class="keyword">import</span> { Generator } <span class="keyword">from</span> <span class="string">'@jspm/generator'</span>;

<span class="keyword">const</span> generator = <span class="keyword">new</span> Generator({
  env: [<span class="string">'browser'</span>, <span class="string">'module'</span>, <span class="string">'production'</span>]
});

<span class="keyword">await</span> generator.install(<span class="string">'lit'</span>);
console.log(generator.getMap());
</code></pre>
<p>To build the import map for the generation operation itself, run Chomp for the <code>importmap.json</code> target (or we could name this task in the Chompfile with <code>name = <span class="string">"build"</span></code>):</p>
<pre><code class="language-sh">chomp importmap.json
</code></pre>
<p>On completion, the full import map for <code>@jspm/generator</code> itself will be populated into <code>importmap.json</code> by the JSPM Chomp template via a Node.js Chomp task.</p>
<p>With the import map constructed, Deno execution of <code>@jspm/generator</code> over the JSPM CDN is now possible with:</p>
<pre><code class="language-sh">deno --unstable run -A --no-check --import-map importmap.json deno-generate.ts
</code></pre>
<p>On completion, the original Lit import map will be displayed, as generated through Deno against JSPM Generator on the JSPM CDN.</p>
<p>Like npm scripts, we can define this Deno execution as a Chomp task itself adding the task to the Chompfile:</p>
<pre><code class="language-toml">[[task]]
name = <span class="string">'deno-generate'</span>
deps = [<span class="string">'importmap.json'</span>]
run = <span class="string">'deno --unstable run -A --no-check --import-map importmap.json deno-generate.ts'</span>
</code></pre>
<p>For an easier <code>chomp deno-generate</code> execution that will first ensure the import map is up to date in the task graph.</p>
<a name="vite-plugin" class="anchor main"></a><h2>Vite Plugin</h2>
<p><a href="https://vitejs.dev/" target="_blank" rel="noopener">Vite</a> is architected primarily to modern ES modules workflows, making JSPM and Vite a great combination.</p>
<p>With the <a href="https://github.com/jspm/vite-plugin-jspm" target="_blank" rel="noopener">JSPM Vite plugin</a>, ddependencies are retrieved from JSPM while the project is bundled using Vite.</p>
<pre><code class="language-sh">npm install vite-plugin-jspm --save-dev
</code></pre>
<p><code>vite</code> and <code>vite build</code> can be used for dev server and production builds respectively. The plugin takes all the options that are supported with <a href="https://github.com/jspm/generator#options" target="_blank" rel="noopener">@jspm/generator</a>.</p>
<p>vite.config.mjs</p>
<pre><code class="language-js"><span class="keyword">import</span> { defineConfig } <span class="keyword">from</span> <span class="string">'vite'</span>;
<span class="keyword">import</span> jspmPlugin <span class="keyword">from</span> <span class="string">'vite-plugin-jspm'</span>;

<span class="keyword">export</span> default defineConfig({
  plugins: [jspmPlugin()],
});
</code></pre>
<p>The plugin will automatically inject ES Module Shims to polyfill import maps.</p>
<p>An additional option that you can use is <code>downloadDeps</code>, to download and build all the dependencies from the JSPM CDN at build time.</p>
<p>When using the <code>downloadDeps</code> option, there are a number of factors that should be considered:</p>
<ul>
<li>Using external CDN dependencies will likely provide the best latency by utilizing the shared globally distributed CDN network - since the JSPM CDN cache is shared at the edge with other JSPM users this leads to shared latency optimization on edges.</li>
<li>Using import maps in production results in there being no need to cache bust the entire build. When there is a small change in project, unchanged dependencies remain cached.</li>
<li>Very minimal footprint of the app as the dependencies are handled by the CDN.</li>
<li>Performance may be faster with or without <code>downloadDeps</code> depending on the exact loading profile and caching requirements.</li>
<li>Having all sources collected together via <code>downloadDeps</code> can be useful for a fully self-contained distribution.</li>
</ul>
<div class="nextprev"><a class="edit" target="_blank" href="https://github.com/jspm/jspm.org/blob/master/docs/workflows.md" rel="noopener">Edit</a><div class="next"><a href="/docs/cdn">Native ES Module CDN - Documentation&nbsp;▶</a></div><div class="prev"><a href="/index">◀&nbsp;JSPM - ES Module Package Manager and CDN</a></div></div></div>
</div>


</body></html>