import { LitElement, html } from 'lit-element';
import { Buffer } from '@jspm/core/nodelibs/buffer';
import zlib from '@jspm/core/nodelibs/zlib';
import CodeMirror from 'codemirror';
import 'codemirror/mode/css/css.js';
import 'codemirror/mode/javascript/javascript.js';
import 'codemirror/mode/xml/xml.js';
import 'codemirror/mode/htmlmixed/htmlmixed.js';
import styles from './sandbox.css' with { type: 'css' };
import { lookup } from '@jspm/generator';

import './console.js';
import './file-explorer.js';
import './editor.js';
import { exampleLandingJs, exampleLandingCss } from './example.js';

import { run } from './run.ts';

const { resolved: { version: esmsVersion } } = await lookup('es-module-shims');
export { esmsVersion }

const defaultIndex = `<!--

JSPM Sandbox

Static no-build sandbox running JSPM in-browser. importmap.js is generated on changes with dependency
mappings, and this index.html executed in an iFrame running ES Module Shims module virtualization.

Project structure:
  * index.html (this file): Loads the JSPM import map and imports the application entry point.
  * package.json: Defines the application "name" and entry point via "exports".
  * index.js: Application entry point.
  * style.css: Stylesheet imported by index.ts using native CSS module imports.
  * importmap.js: Dependency import map generated by JSPM from the application imports.

To eject to a local workflow, download and extract the zip file, run \`npm install -g jspm\`,
and then run \`jspm install\` or \`jspm serve\` to get a local server with the same semantics.

-->

<!DOCTYPE html>
<meta charset="utf-8" />

<!-- Uncomment es-module-shims to polyfill older browsers (i.e. outside of Chrome 133+ and Safari 18.4+) -->
<!-- <script async src="https://ga.jspm.io/npm:es-module-shims@${esmsVersion}/dist/es-module-shims.js"><${""}/script> -->

<script src="importmap.js"></script>
<script type="module">import "app";</script>
`;

export class JspmSandbox extends LitElement {
  static styles = styles;
  static get properties () {
    return {
      selectedUrl: String,
      running: Boolean,
      fileSystem: { type: Object },
      currentFile: { type: String }
    };
  }
  constructor () {
    super();
    this.examples = Object.create(null);
    this.running = false;
    this.fileSystem = { 
      'index.html': defaultIndex,
      'index.js': exampleLandingJs,
      'style.css': exampleLandingCss,
      'importmap.js': '',
      'package.json': `{
  "name": "app",
  "version": "1.0.0",
  "type": "module",
  "exports": {
    ".": "./index.js"
  },
  "dependencies": {}
}
`
    };
    this.currentFile = 'index.html';
    
    for (const example of this.children)
      this.examples[example.getAttribute('name')] = example.getAttribute('content');
    
    // Initialize from URL or example
    this.initializeFromUrl();
    
    // Restore selected file from localStorage
    this.restoreSelectedFile();
    
    // Listen for URL changes
    window.addEventListener('popstate', () => {
      this.initializeFromUrl();
      this.requestUpdate();
      this.handleSave();
    });

    window.addEventListener('hashchange', () => {
      this.initializeFromUrl();
      this.requestUpdate();
    });
    
    // Save editor state before page unload
    window.addEventListener('beforeunload', () => {
      if (this.currentFile && this.$editor) {
        this.saveEditorState(this.currentFile);
      }
    });
  }

  initializeFromUrl() {
    const hash = location.hash;
    if (hash && hash.length > 1) {
      try {
        // Try to decode as new format (compressed fileSystem)
        const decoded = zlib.gunzipSync(Buffer.from(hash.slice(1), 'base64')).toString('utf8');
        const parsedData = JSON.parse(decoded);
        
        if (typeof parsedData === 'object' && !Array.isArray(parsedData)) {
          // New format: fileSystem object
          this.fileSystem = parsedData;
          this.ensureSpecialFiles();
          this.currentFile = 'index.html';
        } else {
          // Old format: single file content
          this.fileSystem = { 'index.html': decoded };
          this.ensureSpecialFiles();
          this.currentFile = 'index.html';
        }
      } catch (e) {
        // If decoding fails, try old format or use example
        try {
          const decoded = zlib.gunzipSync(Buffer.from(hash.slice(1), 'base64')).toString('utf8');
          this.fileSystem = { 'index.html': decoded };
          this.ensureSpecialFiles();
          this.currentFile = 'index.html';
        } catch (e2) {
          // Fall back to example
          const exampleUrl = Object.values(this.examples)[0];
          if (exampleUrl) {
            this.initializeFromExample(exampleUrl);
          }
        }
      }
    } else {
      // No hash, use first example
      const exampleUrl = Object.values(this.examples)[0];
      if (exampleUrl) {
        this.initializeFromExample(exampleUrl);
      }
    }
  }

  initializeFromExample(exampleUrl) {
    if (exampleUrl && exampleUrl[0] === '#') {
      try {
        const decoded = zlib.gunzipSync(Buffer.from(exampleUrl.slice(1), 'base64')).toString('utf8');
        this.fileSystem = { 'index.html': decoded };
        this.ensureSpecialFiles();
      } catch (e) {
        console.error('Failed to decode example:', e);
      }
    }
  }

  ensureSpecialFiles() {
    // Ensure special files exist if they're not in the loaded fileSystem
    if (!this.fileSystem['importmap.js']) {
      this.fileSystem['importmap.js'] = '';
    }
    if (!this.fileSystem['index.js']) {
      this.fileSystem['index.js'] = '// Entry point code\n';
    }
    if (!this.fileSystem['package.json']) {
      this.fileSystem['package.json'] = '{\n  "name": "app",\n  "version": "1.0.0",\n  "type": "module",\n  "exports": {\n    ".": "./index.js"\n  },\n  "dependencies": {}\n}\n';
    }
    if (!this.fileSystem['index.html']) {
      this.fileSystem['index.html'] = defaultIndex;
    }
  }
  firstUpdated () {
    this.$editor = this.shadowRoot.querySelector('jspm-editor');
    this.$browserWrapper = this.shadowRoot.querySelector('.browser-wrapper');
    this.$console = this.shadowRoot.querySelector('jspm-console');
    this.$outputContainer = this.shadowRoot.querySelector('.output-container');
    this.$fileExplorer = this.shadowRoot.querySelector('jspm-file-explorer');
    this.$editorPane = this.shadowRoot.querySelector('.editor-pane');
    this.$output = this.shadowRoot.querySelector('.output');
    
    // Initialize resize state
    this.isResizing = false;
    this.isHorizontalResizing = false;
    
    // Load saved widths from localStorage
    const savedFileExplorerWidth = localStorage.getItem('jspm-sandbox-file-explorer-width');
    const savedEditorWidth = localStorage.getItem('jspm-sandbox-editor-width');
    
    if (savedFileExplorerWidth) {
      this.$fileExplorer.style.width = savedFileExplorerWidth + 'px';
    }
    if (savedEditorWidth) {
      this.$editorPane.style.flex = 'none';
      this.$editorPane.style.width = savedEditorWidth + 'px';
      // Make sure output takes remaining space
      this.$output.style.flex = '1';
    }
    
    // Load saved console size from localStorage
    const savedBrowserHeight = localStorage.getItem('jspm-sandbox-browser-height');
    this.browserHeight = savedBrowserHeight ? parseFloat(savedBrowserHeight) : 50;
    
    // Apply saved size
    this.$browserWrapper.style.height = `${this.browserHeight}%`;
    this.$console.style.height = `${100 - this.browserHeight}%`;
    
    // Restore editor state for initial file after editor is ready
    if (this.$editor) {
      this.$editor.updateComplete.then(() => {
        setTimeout(() => {
          this.restoreEditorState(this.currentFile);
        }, 100);
      });
    }
    
    function keydown (e) {
      if ((e.key === 'p' || e.key === 'P') && e.ctrlKey) {
        // import('./sandboxcmd.js');
        e.preventDefault();
        window.removeEventListener('keydown', keydown);
      }
    }
    window.addEventListener('keydown', keydown);
  }
  
  startResize(e) {
    this.isResizing = true;
    this.startY = e.clientY;
    this.startHeight = this.$browserWrapper.offsetHeight;
    
    // Create overlay to prevent iframe from capturing mouse events
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 9999;
      cursor: ns-resize;
    `;
    this.$outputContainer.appendChild(overlay);
    
    const handleMouseMove = (e) => {
      if (!this.isResizing) return;
      
      const containerHeight = this.$outputContainer.offsetHeight;
      const deltaY = e.clientY - this.startY;
      const newHeight = this.startHeight + deltaY;
      const heightPercent = (newHeight / containerHeight) * 100;
      
      // Limit between 20% and 80%
      if (heightPercent >= 20 && heightPercent <= 80) {
        this.browserHeight = heightPercent;
        this.$browserWrapper.style.height = `${heightPercent}%`;
        this.$console.style.height = `${100 - heightPercent}%`;
      }
    };
    
    const handleMouseUp = () => {
      this.isResizing = false;
      overlay.remove();
      
      // Save the final console size to localStorage
      if (this.browserHeight) {
        localStorage.setItem('jspm-sandbox-browser-height', this.browserHeight.toString());
      }
      
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }
  
  startHorizontalResize(e, target) {
    e.preventDefault();
    this.isHorizontalResizing = true;
    this.resizeTarget = target;
    this.startX = e.clientX;
    
    if (target === 'fileExplorer') {
      this.startWidth = this.$fileExplorer.offsetWidth;
    } else {
      this.startWidth = this.$editorPane.offsetWidth;
    }
    
    // Create overlay to prevent iframe and codemirror from capturing mouse events
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 99999;
      cursor: ew-resize;
      background: transparent;
    `;
    document.body.appendChild(overlay);
    
    const handleMouseMove = (e) => {
      if (!this.isHorizontalResizing) return;
      
      const deltaX = e.clientX - this.startX;
      const newWidth = this.startWidth + deltaX;
      
      if (this.resizeTarget === 'fileExplorer') {
        // Limit file explorer width between 150px and 400px
        if (newWidth >= 150 && newWidth <= 400) {
          this.$fileExplorer.style.width = newWidth + 'px';
        }
      } else {
        // For editor resize, just ensure minimum width
        const minWidth = 200;
        
        if (newWidth >= minWidth) {
          this.$editorPane.style.flex = 'none';
          this.$editorPane.style.width = newWidth + 'px';
          // Let the output panel take the remaining space
          this.$output.style.flex = '1';
        }
      }
    };
    
    const handleMouseUp = () => {
      this.isHorizontalResizing = false;
      overlay.remove();
      
      // Save the widths to localStorage
      if (this.resizeTarget === 'fileExplorer') {
        localStorage.setItem('jspm-sandbox-file-explorer-width', this.$fileExplorer.offsetWidth);
      } else {
        localStorage.setItem('jspm-sandbox-editor-width', this.$editorPane.offsetWidth);
      }
      
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }
  render () {
    return html`
      <jspm-file-explorer 
        .files=${this.fileSystem}
        .selectedFile=${this.currentFile}
        @file-selected=${this.handleFileSelected}
        @create-file=${this.handleCreateFile}
        @create-folder=${this.handleCreateFolder}
        @delete-file=${this.handleDeleteFile}
        @delete-folder=${this.handleDeleteFolder}
        @rename-item=${this.handleRename}
      ></jspm-file-explorer>
      <div class="vertical-resize-handle" @mousedown=${(e) => this.startHorizontalResize(e, 'fileExplorer')}></div>
      <div class="editor-pane">
        <jspm-editor 
          .contents="${this.fileSystem[this.currentFile] || ''}" 
          .currentFile=${this.currentFile}
          .readOnly=${this.currentFile === 'importmap.js'}
          @load=${this.run} 
          @save=${this.handleSave}
          @hot=${this.handleHot}
        ></jspm-editor>
      </div>
      <div class="vertical-resize-handle-2" @mousedown=${(e) => this.startHorizontalResize(e, 'editor')}></div>
      <div class="output">
        <div class="browser-bar">
          <button class="run" @click=${this.run} ?disabled=${this.running}>
            <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle; margin-right: 0.4em;">
              <path d="M4 2v12l10-6z"/>
            </svg>
            Run (Ctrl+S)
          </button>
          <button class="download" @click=${this.downloadProject}>
            <svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle; margin-right: 0.4em;">
              <path d="M7.5 1v9.5L4 7l-1 1 5 5 5-5-1-1-3.5 3.5V1h-1z"/>
              <path d="M14 13v2H2v-2H1v2.5l.5.5h13l.5-.5V13h-1z"/>
            </svg>
            Download
          </button>
        </div>
        <div class="output-container" style="position: absolute; width: 100%; height: calc(100% - 3em); top: 3em; z-index: 11;">
          <div class="browser-wrapper" style="width:100%;"></div>
          <div class="resize-handle" @mousedown=${this.startResize}></div>
          <jspm-console></jspm-console>
        </div>
      </div>
    `;
  }
  handleFileSelected(e) {
    const { path } = e.detail;
    // Save current file
    if (this.currentFile && this.$editor) {
      const currentContent = this.$editor.getContents();
      // Save editor state (cursor position, selection)
      this.saveEditorState(this.currentFile);
      this.fileSystem[this.currentFile] = currentContent;
      // Update URL when switching files
      this.updateUrl();
    }
    // Switch to new file
    this.currentFile = path;
    // Save selected file to localStorage
    localStorage.setItem('jspm-sandbox-selected-file', path);
    this.requestUpdate();
  }

  handleSave() {
    // Save current file contents and editor state
    if (this.currentFile && this.$editor) {
      const content = this.$editor.getContents();
      // Save editor state
      this.saveEditorState(this.currentFile);
      this.fileSystem[this.currentFile] = content;
    }
    // Update URL with compressed file system
    this.updateUrl();
    this.run();
  }

  handleHot() {
    // Update current file contents and editor state
    // without updating the persistent state
    if (this.currentFile && this.$editor) {
      const content = this.$editor.getContents();
      this.fileSystem[this.currentFile] = content;
      // TODO: Fix es-module-shims hot reload support for virtual JS files
      if (!this.currentFile.endsWith('.js') && !this.currentFile.endsWith('.ts'))
        this.iframe?.contentWindow?.importShim.hotReload('file:///virtual-pkg/' + this.currentFile);
    }
  }

  updateUrl() {
    try {
      const compressed = zlib.gzipSync(Buffer.from(JSON.stringify(this.fileSystem))).toString('base64');
      const newHash = '#' + compressed;
      window.history.pushState(null, document.title, newHash);
    } catch (e) {
      console.error('Failed to update URL:', e);
    }
  }

  handleCreateFile(e) {
    const { path } = e.detail;
    if (path && !this.fileSystem[path]) {
      this.fileSystem[path] = '';
      this.currentFile = path;
      this.updateUrl();
      this.requestUpdate();
    }
  }

  handleCreateFolder(e) {
    const { path } = e.detail;
    if (path) {
      // Create an index.js file to represent the folder
      const indexFile = `${path}/index.js`;
      if (!this.fileSystem[indexFile]) {
        this.fileSystem = {
          ...this.fileSystem,
          [indexFile]: '// ' + path + ' module\n\nexport default {\n  // Add your exports here\n};\n'
        };
        this.currentFile = indexFile;
        this.updateUrl();
        this.requestUpdate();
      }
    }
  }

  handleDeleteFile(e) {
    const { path } = e.detail;
    if (path && this.fileSystem[path] !== undefined) {
      // Create new fileSystem without the deleted file
      const newFileSystem = { ...this.fileSystem };
      delete newFileSystem[path];
      this.fileSystem = newFileSystem;
      
      // If we deleted the current file, switch to index.html
      if (this.currentFile === path) {
        this.currentFile = 'index.html';
      }
      
      this.updateUrl();
      this.requestUpdate();
    }
  }

  handleDeleteFolder(e) {
    const { path } = e.detail;
    // Delete all files in the folder
    let deletedAny = false;
    
    Object.keys(newFileSystem).forEach(filePath => {
      if (filePath.startsWith(path + '/')) {
        delete newFileSystem[filePath];
        deletedAny = true;
      }
    });
    
    if (deletedAny) {
      // If current file was in deleted folder, switch to index.html
      if (this.currentFile.startsWith(path + '/')) {
        this.currentFile = 'index.html';
      }
      
      this.updateUrl();
      this.requestUpdate();
    }
  }

  handleRename(e) {
    const { oldPath, newPath, type } = e.detail;
    
    if (type === 'file') {
      // Rename a single file
      if (this.fileSystem[oldPath] !== undefined && !this.fileSystem[newPath]) {
        const newFileSystem = { ...this.fileSystem };
        newFileSystem[newPath] = newFileSystem[oldPath];
        delete newFileSystem[oldPath];
        this.fileSystem = newFileSystem;
        
        // If we renamed the current file, update currentFile
        if (this.currentFile === oldPath) {
          this.currentFile = newPath;
        }
        
        this.updateUrl();
        this.requestUpdate();
      }
    } else if (type === 'folder') {
      // Rename all files in the folder
      let renamedAny = false;
      
      Object.keys(this.fileSystem).forEach(filePath => {
        if (filePath === oldPath || filePath.startsWith(oldPath + '/')) {
          const newFilePath = filePath.replace(oldPath, newPath);
          if (!newFileSystem[newFilePath]) {
            newFileSystem[newFilePath] = newFileSystem[filePath];
            delete newFileSystem[filePath];
            renamedAny = true;
            
            // Update current file if it was in the renamed folder
            if (this.currentFile === filePath) {
              this.currentFile = newFilePath;
            }
          }
        }
      });
      
      if (renamedAny) {
        this.updateUrl();
        this.requestUpdate();
      }
    }
  }

  saveEditorState(filePath) {
    if (!this.$editor || !this.$editor.editor) return;
    
    const editor = this.$editor.editor;
    const cursor = editor.getCursor();
    const selection = editor.getSelection();
    const scrollInfo = editor.getScrollInfo();
    
    const state = {
      cursor: { line: cursor.line, ch: cursor.ch },
      selection: selection,
      scroll: { top: scrollInfo.top, left: scrollInfo.left }
    };
    
    localStorage.setItem(`jspm-sandbox-editor-state-${filePath}`, JSON.stringify(state));
  }

  restoreEditorState(filePath) {
    if (!this.$editor || !this.$editor.editor) return;
    
    const savedState = localStorage.getItem(`jspm-sandbox-editor-state-${filePath}`);
    if (!savedState) return;
    
    try {
      const state = JSON.parse(savedState);
      const editor = this.$editor.editor;
      
      // Restore cursor position
      if (state.cursor) {
        editor.setCursor(state.cursor.line, state.cursor.ch);
      }
      
      // Restore selection
      if (state.selection) {
        editor.setSelection(state.selection);
      }
      
      // Restore scroll position
      if (state.scroll) {
        editor.scrollTo(state.scroll.left, state.scroll.top);
      }
      
      // Focus the editor to make cursor visible
      editor.focus();
    } catch (e) {
      console.warn('Failed to restore editor state:', e);
    }
  }

  restoreSelectedFile() {
    const savedFile = localStorage.getItem('jspm-sandbox-selected-file');
    if (savedFile && this.fileSystem[savedFile]) {
      this.currentFile = savedFile;
      // Ensure file explorer is updated
      this.requestUpdate();
    }
  }

  async downloadProject() {
    try {
      // Dynamically import JSZip
      const { default: JSZip } = await import('jszip');
      
      // Create a new zip file
      const zip = new JSZip();
      
      // Add all files to the zip
      Object.entries(this.fileSystem).forEach(([path, content]) => {
        zip.file(path, content);
      });
      
      // Generate the zip file
      const blob = await zip.generateAsync({ type: 'blob' });
      
      // Create a download link and trigger it
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'jspm-project.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    } catch (error) {
      console.error('Failed to download project:', error);
      alert('Failed to download project. Please try again.');
    }
  }

  updated(changedProperties) {
    super.updated(changedProperties);
    
    // If currentFile changed, restore editor state for the new file
    if (changedProperties.has('currentFile') && this.$editor) {
      // Wait for the editor to finish updating
      this.$editor.updateComplete.then(() => {
        // Additional delay to ensure CodeMirror has processed the content
        setTimeout(() => {
          this.restoreEditorState(this.currentFile);
        }, 50);
      });
    }
  }

  async run () {
    let started = false;
    this.$console.clear();
    this.iframe = await run({
      browserWrapper: this.$browserWrapper,
      fileSystem: this.fileSystem,
      sandboxStart () {
        started = true;
      },
      sandboxExecuted: () => {
        if (!started) {
          if (this.running) {
            this.$console.log(
              "Network error loading modules. Check the browser network panel."
            );
            this.running = false;
            this.iframe.contentDocument.body.style.cursor = "default";
          }
        } else {
          this.running = false;
          this.iframe.contentDocument.body.style.cursor = "default";
        }
      },
      sandboxError: (msg, source, line, col, err) => {
        if (this.running) {
          this.running = false;
          this.iframe.contentDocument.body.style.cursor = "default";
        }
        let parts = (err.stack || err).split(this.iframe.src);
        if (parts.length === 1) {
          if (line === 1) col = col - 72;
          parts = [`${msg} sandbox:${line}:${col}`];
        }
        this.$console.log(parts.join("sandbox"), { color: "red" });
      },
    });
    this.running = true;
    window.jspmConsole = this.$console.api;
    this.updateUrl();
  }
}
customElements.define('jspm-sandbox', JspmSandbox);
