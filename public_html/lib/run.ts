import { Generator } from "@jspm/generator";
import { parse } from './script-lexer.js';
import { esmsVersion } from './sandbox.js';

export async function run({
  fileSystem,
  browserWrapper,
  sandboxStart,
  sandboxExecuted,
  sandboxError,
}: {
  fileSystem: Record<string, string>;
  browserWrapper: HTMLElement;
  sandboxStart: () => void;
  sandboxError: (msg, source, line, col, err) => void;
  sandboxExecuted: () => void;
}) {
  let pjson;
  try {
    pjson = JSON.parse(fileSystem["package.json"]);
  } catch (e) {
    throw new Error(`Error parsing package.json file - ${e.message}`);
  }

  if (pjson.jspm) {
    const { jspm } = pjson;
    delete pjson.jspm;
    Object.assign(pjson, jspm);
  }

  let inputMap = {};
  const inputMapSource = fileSystem["importmap.js"];
  if (inputMapSource) {
    const source = inputMapSource.slice(
      inputMapSource.indexOf("})\n({") + 4,
      inputMapSource.lastIndexOf("});") + 1
    );
    try {
      inputMap = JSON.parse(source);
    } catch {}
  }

  try {
    const generator = new Generator({
      env: ["development", "module", "browser"],
      mapUrl: "file:///virtual-pkg/importmap.js",
      baseUrl: '/',
      inputMap,
      scopedLink: true,
    });
    generator.setVirtualSourceData("file:///virtual-pkg/", fileSystem);
    await generator.install(
      { target: "file:///virtual-pkg/", subpaths: true },
      "freeze"
    );

    const importMap = generator.map.rebase("about:blank").toJSON();
    const rebasedImportMap = generator.map
      .clone()
      .rebase("file:///virtual-pkg/")
      .toJSON();
    const mapStr = JSON.stringify(importMap, null, 2);

    fileSystem["importmap.js"] = `// This file is auto-generated by "jspm install" or Ctrl+S on JSPM Sandbox.
// package.json "exports" entry points are traced to automatically populate the dependency mappings.
(map => {
  const mapUrl = document.currentScript.src;
  const resolve = imports => Object.fromEntries(Object.entries(imports).map(([k, v]) => [k, new URL(v, mapUrl).href]));
  document.head.appendChild(Object.assign(document.createElement("script"), {
    type: "importmap-shim",
    innerHTML: JSON.stringify({
      imports: resolve(map.imports),
      scopes: Object.fromEntries(Object.entries(map.scopes).map(([k, v]) => [new URL(k, mapUrl).href, resolve(v)]))
    })
  }));
})
(${JSON.stringify(rebasedImportMap, null, 2)});
`;

    let source = fileSystem["index.html"];
    let parsed;
    try {
      parsed = parse(source);
    }
    catch {}

    if (parsed) {
      let offset = 0;
      function replace(start, end, replacement) {
        source = source.slice(0, start + offset) + replacement + source.slice(end + offset);
        offset += replacement.length - (end - start);
      }
      for (const { start, end, attributes } of parsed) {
        if (source.slice(start + offset, end + offset) === '<script src="importmap.js"></script>') {
          replace(start, end, `<script type="importmap-shim">${mapStr}</script>`);
          continue;
        }
        for (const { nameStart, nameEnd, valueStart, valueEnd } of attributes) {
          const name = source.slice(nameStart + offset, nameEnd + offset);
          const val = source.slice(valueStart + offset, valueEnd + offset);
          if (name === 'type' && val === 'module' || val === 'importmap') {
            replace(valueStart, valueEnd, val + '-shim');
            break;
          }
        }
      }
    } else {
      source = source
        .replace(
          '<script src="importmap.js"></script>',
          `<script type="importmap-shim">${mapStr}</script>`
        )
        .replace(/<script type="module"/g, '<script type="module-shim"')
        .replace(/<script type="importmap"/g, '<script type="importmap-shim"');
    }

    globalThis.jspmFileSystem = fileSystem;
    globalThis.jspmSandboxStarted = sandboxStart;
    globalThis.jspmSandboxFinished = sandboxExecuted;
    globalThis.jspmSandboxError = sandboxError;
    const script = document.createElement("script");
    script.type = "module";
    const iframe = document.createElement("iframe");
    Object.assign(iframe.style, {
      margin: "0",
      padding: "0",
      borderStyle: "none",
      height: "100%",
      width: "100%",
      marginBottom: "-5px", // no idea, but it works
      overflow: "scroll",
    });

    let needsShim = true;
    if (parsed)
    for (const { start, end } of parsed) {
      if (source.slice(start, end).match(/es-module-shims(.min)?.js/))
        needsShim = false;
    }
    const blobUrl = URL.createObjectURL(
      new Blob(
        [
          `${`
        <style>
          body {
            background-color: white;
          }
        </style>
        <script>
        window.console = window.parent.jspmConsole;
        window.onerror = function (msg, source, line, col, err) {
          window.parent.jspmSandboxError(msg, source, line, col, err || msg);
        };
        self.esmsInitOptions = {
          onpolyfill:() => {},
          hotReload: true,
          source:(url, fetchOpts, parentUrl, defaultSourceHook) => {
            if (!url.startsWith('file:///virtual-pkg/')) return defaultSourceHook(url, fetchOpts, parent);
            const versionQueryParam = url.match(/\\?v=\\d+$/);
            if (versionQueryParam) url = url.slice(0, -versionQueryParam[0].length);
            let source = window.parent.jspmFileSystem[url.slice('file:///virtual-pkg/'.length)];
            if (!source) throw new Error(\`Virtual module \${url} not found, imported from \${parent}\`);
            source += '\\n//# sourceURL=about:blank\\n';
            switch (url.slice(url.lastIndexOf('.') + 1)) {
              case 'mjs': case 'js': return { type: 'js', source };
              case 'wasm': return { type: 'wasm', source };
              case 'css': return { type: 'css', source };
              case 'json': return { type: 'json', source };
              case 'tsm': case 'ts': return { type: 'ts', source };
            }
          },
          onerror:e=>window.parent.jspmSandboxError(e.message || e, '', '', '', e)
        };
        </script>
        ${
          needsShim
            ? `<script async src="https://ga.jspm.io/npm:es-module-shims@${esmsVersion}/dist/es-module-shims.js"><${""}/script>`
            : ""
        }
        <script>window.parent.jspmSandboxStarted()<${""}/script>`
            .split("\n")
            .join("\n")}${source}
        <script type="module-shim">window.parent.jspmSandboxFinished()<${""}/script>
      `,
        ],
        { type: "text/html" }
      )
    );
    iframe.src = blobUrl;
    browserWrapper.innerHTML = "";
    browserWrapper.appendChild(iframe);
    return iframe;
  } catch (e) {
    browserWrapper.innerHTML = "";
    throw e;
  }
}
